(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{414:function(e,t,s){"use strict";s.r(t);var r=s(44),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"process-and-thread"}},[e._v("Process and Thread")]),e._v(" "),s("p",[e._v("The concepts of "),s("code",[e._v("process")]),e._v(" and "),s("code",[e._v("thread")]),e._v(" is developed gradually, so that we are confused a lot by different documents.")]),e._v(" "),s("h2",{attrs:{id:"before-1960s"}},[e._v("Before 1960s")]),e._v(" "),s("p",[e._v("There is no "),s("code",[e._v("thread")]),e._v(" at all. The process mean:")]),e._v(" "),s("ol",[s("li",[e._v("The basic unit of dispatch and execution;")]),e._v(" "),s("li",[e._v("Ownership of resources including program context. Operation system will protect the owership to avoiding resource conflict.")])]),e._v(" "),s("h2",{attrs:{id:"after-1960s-before-2003"}},[e._v("After 1960s Before 2003")]),e._v(" "),s("p",[e._v("In 1967, IBM developed OS/360 and realized "),s("strong",[e._v("Multiprogramming with a Variable Number of Tasks")]),e._v(". Operation system switch process by switching process context -- that's what we said "),s("strong",[e._v("concurrency")]),e._v(". During this time, tasks looked like thread indeed. The term of thread alse made an early appearance. In this model, thread existed in the form of user-level-thread. Operation system did not aware of the existence of thread and still dispatched process.")]),e._v(" "),s("h2",{attrs:{id:"after-2003"}},[e._v("After 2003")]),e._v(" "),s("p",[e._v("Intel and AMD have found out a fact the growth of the CPU frequency barely improve the entire performance. The performance would even decreased because of overheating. We need a processor be able to solve more than 2 threads. In 2004, Pentium 4 realized Hyper-Threading. And in 2005, Intel announced its "),s("code",[e._v("EM64T")]),e._v(" processor with "),s("strong",[e._v("2 cores")]),e._v(" and "),s("code",[e._v("Pentium D840")]),e._v(". Every core can solve more than one threads and thread and process became different totally.")]),e._v(" "),s("ul",[s("li",[e._v("Thread is basic unit of execution and dispatch;")]),e._v(" "),s("li",[e._v("Process is the ownership or resources.")])]),e._v(" "),s("h2",{attrs:{id:"why-we-need"}},[e._v("Why we need?")]),e._v(" "),s("ol",[s("li",[e._v("The creation, termination and switching overhead of a thread is much lower than a process's.")]),e._v(" "),s("li",[e._v("Due to sharing address space, the communication of threads is much more effient than processes'.")])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"left"}},[e._v("Per process items")]),e._v(" "),s("th",{staticStyle:{"text-align":"left"}},[e._v("Per thread items")])])]),e._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"left"}},[e._v("Address space")]),e._v(" "),s("td",{staticStyle:{"text-align":"left"}},[e._v("Program counter")])]),e._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[e._v("Global variables")]),e._v(" "),s("td",{staticStyle:{"text-align":"left"}},[e._v("Registers")])]),e._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[e._v("Open files")]),e._v(" "),s("td",{staticStyle:{"text-align":"left"}},[e._v("Stack")])]),e._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[e._v("Child processes")]),e._v(" "),s("td",{staticStyle:{"text-align":"left"}})]),e._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[e._v("Pending alarms")]),e._v(" "),s("td",{staticStyle:{"text-align":"left"}})]),e._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[e._v("Signals and signal handlers")]),e._v(" "),s("td",{staticStyle:{"text-align":"left"}})]),e._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"left"}},[e._v("Accounting information")]),e._v(" "),s("td",{staticStyle:{"text-align":"left"}})])])]),e._v(" "),s("p",[e._v("Besides, the processor is conscious of the existence of threads and dispatch them -- that's "),s("strong",[e._v("Kernel mode")]),e._v(" which is most prevalent model. So in the classical proceess-thread model - "),s("code",[e._v("kenel-level threads supported Unix")]),e._v(":")]),e._v(" "),s("ol",[s("li",[e._v("Process is "),s("strong",[e._v("container")]),e._v(" of resources, include at least one threads;")]),e._v(" "),s("li",[e._v("The basic unit of Kernel dispatchment is "),s("strong",[e._v("thread")]),e._v(" instead of process; (I think I wrote this sentence 3 times ...)")]),e._v(" "),s("li",[e._v("All threads in the same process share the "),s("strong",[e._v("shared resouces")]),e._v(", including address space, open files, etc. But they maintain their own registers, stacks(about 1M), PC, etc.")])]),e._v(" "),s("h2",{attrs:{id:"important-exception-linux"}},[e._v("Important exception - Linux!")]),e._v(" "),s("p",[e._v("Linux is different from the classical model. The boundary between thread and process is pretty 'fuzzy'.")]),e._v(" "),s("h3",{attrs:{id:"linus-view"}},[e._v("Linus' view")]),e._v(" "),s("p",[e._v("The "),s("a",{attrs:{href:"http://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("email"),s("OutboundLink")],1),e._v(" is from Linus in 1996. His main point is following:")]),e._v(" "),s("blockquote",[s("p",[e._v("There is NO reason to think 'threads' and 'processes' are separate entities. He thought the only difference is '"),s("strong",[e._v("context of execution")]),e._v("'...")])]),e._v(" "),s("blockquote",[s("p",[e._v('A "context of execution", hereby called COE, is just the conglomerate of all the state of that COE. That state includes things like CPU state (registers etc), MMU state (page mappings), permission state (uid, gid) and various "communication states" (open files, signal handlers etc).')])]),e._v(" "),s("p",[e._v("Anyway, the viewpoint of Linus was still somehow similar to the classical model at least in the sharing resource aspect.")]),e._v(" "),s("h3",{attrs:{id:"task-instead-of-process-or-thread"}},[e._v("Task instead of Process or Thread")]),e._v(" "),s("p",[e._v("In Linux OS, "),s("code",[e._v("task_struct")]),e._v(" is the data structure represent both process and thread.")]),e._v(" "),s("blockquote",[s("p",[e._v("Everything is simply a runnable task.")])]),e._v(" "),s("p",[e._v("In this way, a process with "),s("code",[e._v("single-thread")]),e._v(" is represented by one "),s("code",[e._v("task_struct")]),e._v(" while a process with "),s("code",[e._v("multi-thread")]),e._v(" is represented by multiple "),s("code",[e._v("task_struct")]),e._v(".")]),e._v(" "),s("p",[e._v("In 2000, Linux introduce a new system call "),s("code",[e._v("clone")]),e._v(" which is similar to "),s("code",[e._v("fork")]),e._v(". But it can allocate the resource by the "),s("code",[e._v("thread")]),e._v(" layer! This make their boundary more obscure. Because no matter what it is a process or thread, it is created by "),s("code",[e._v("clone")]),e._v(" a "),s("code",[e._v("task")]),e._v(" existed fundamentally. When "),s("code",[e._v("CLONE_VM")]),e._v(" is set, there is a thread created. When "),s("code",[e._v("CLONE_VM")]),e._v(" is NOT set, there is a process created.")]),e._v(" "),s("p",[e._v("As for kernel of Linux, every task has its unique "),s("code",[e._v("PID(Process IDentifier)")]),e._v(", though it may be a thread in classical model. Also every task has a "),s("code",[e._v("TGID(Task Group ID)")]),e._v(". The threads in same process have the same "),s("code",[e._v("TGID")]),e._v(".")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("Why PID?")]),e._v(" "),s("p",[e._v("The name of PID(Process IDentifier) is too popular to be given up. And Linus did not regard thread and process as the different entities.")])]),e._v(" "),s("h3",{attrs:{id:"top-ps"}},[e._v("TOP PS")]),e._v(" "),s("p",[e._v("The instuction "),s("code",[e._v("TOP")]),e._v(", "),s("code",[e._v("PS")]),e._v(" return different "),s("code",[e._v("PID")]),e._v(" really confused me a lot until I found this "),s("a",{attrs:{href:"https://www.zhihu.com/question/44087187/answer/136188761",target:"_blank",rel:"noopener noreferrer"}},[e._v("answer"),s("OutboundLink")],1),e._v(".")]),e._v(" "),s("h2",{attrs:{id:"reference"}},[e._v("Reference:")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://www.zhihu.com/question/44087187/answer/136188761",target:"_blank",rel:"noopener noreferrer"}},[e._v("进程和线程之间有什么根本性的区别? - by linH"),s("OutboundLink")],1),s("br"),e._v(" "),s("a",{attrs:{href:"https://www.zhihu.com/question/44087187/answer/96885903",target:"_blank",rel:"noopener noreferrer"}},[e._v("进程和线程之间有什么根本性的区别? - by Anonym"),s("OutboundLink")],1),s("br"),e._v(" "),s("a",{attrs:{href:"https://www.zhihu.com/question/44087187/answer/1956524384",target:"_blank",rel:"noopener noreferrer"}},[e._v("进程和线程之间有什么根本性的区别? - by Bing"),s("OutboundLink")],1),s("br"),e._v(" "),s("a",{attrs:{href:"https://stackoverflow.com/questions/9305992/if-threads-share-the-same-pid-how-can-they-be-identified",target:"_blank",rel:"noopener noreferrer"}},[e._v("If threads share the same PID, how can they be identified?"),s("OutboundLink")],1),s("br"),e._v(" "),s("a",{attrs:{href:"https://www.zhihu.com/question/21823699/answer/111606716",target:"_blank",rel:"noopener noreferrer"}},[e._v("指令级并行，线程级并行，数据级并行区别？线程的概念是什么？"),s("OutboundLink")],1),s("br"),e._v(" "),s("a",{attrs:{href:"https://erlang.org/doc/getting_started/conc_prog.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concurrent Programming"),s("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);